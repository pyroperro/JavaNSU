# Задание 2. Шаблон проектирования «фабричный метод», журналирование, модульное тестирование
**Условие.** Написать стековый калькулятор, который принимает в качестве аргумента командой строки имя файла, содержащего команды. Если аргумента нет, то использовать стандартный поток ввода для чтения команд. Реализовать следующий набор команд:
1. \#  — строка с комментарием.
2. POP, PUSH — снять/положить число со/на стек(а).
3. \+ , - , * , /, SQRT — арифметические операции. Используют один или два верхних элемента стека, изымают их из стека, помещая результат назад
4. PRINT — печать верхнего элемента стека (без удаления).
5. DEFINE — задать значение параметра. В дальнейшем везде использовать вместо
параметра это значение.

## Архитектура
- **Класс `Context`.** Контекст исполнения --- служит для передачи изменяющихся данных коммандам калькулятора. Содержит поля `Stack<Float> stack` и `Map<String, Float> varList` --- текущее состояние стека и словарь "переменная-значение". Реализует доступ к стеку (`push(float value)`, `pop()`, `peek()`, `isEmpty()`, `stackSize()`), а так же добавление и поиск переменных в словаре.
- **Интерфейс `Command`.** Для фабричного метода необходимо определить общий интерфей (абстрактный класс), который будут реализавать объекты, порожденные фабрикой. `Command` обладает единственным методом `execute(Context context, String[] args)`, исполняющий соответствующую команду в зависимости от класса объекта.
- **Наследники класса `Command`.** Классы `Add`, `Multiply`, `Push`, `Pop`, `Define` и др. реализуют интерфейс `Command` в зависимости от своего названия.
- **Фабрика команд `CommandFactory`.** Содержит поле `Map<String, String> commandNames`--- словарь, ставящий в соответствие названия команд и имена соответствующих классов. Данный словарь заполняется конструктором, принимающим путь к файлу конфигурации. Файл преобразуется в `InputStream` поток входных данных, после чего `BufferedReader` проходит по строкам и заполняет словарь. 
Метод `createCommand(string commandName)` создает экземпляр соответствующего класса команд по названию. Для этого объявляется объект неизвестного класса, который инициализируется нужным классом с помощью метода `forName(className)`. Далее фабрика возвращает instance класса полученный методом `newInstance()` нужного конструктора `getDeclaredConstructor()`.
```Java
Class<?> commandClass = Class.forName(className);  
return (Command) commandClass.getDeclaredConstructor().newInstance();
```
- **Основной класс `Calculator`.** Реализует логгирование и работу калькулятора. Парсит команды из файла или консоли, создает команды с помощью фабрики и выполняет их.
## Иерархия исключений
Самый нижний уровень, на котором может произойти исключение, это `Context`. Например, `findVariable` может выкинуть `NoSuchElementException` в случае попытки поиска несуществующей переменной. 
Далее, исключения из контекста передаются команде, вызывающей его метод. Тут могут возникнуть свои исключения, например `IllegalArgumentException` при попытке взятия корня из отрицательного числа. Важно, чтобы после получения исключения состояние стека после выполнение ошибочной команды не изменялось. Все исключения команд передаются дальше в объект класса `Calculator`.
Помимо `Command`, калькулятор может получить исключение от фабрики в случае, если была вызвана команда не определенная конфигурационным файлом.
Все исключения выше не являются критичными для работы программы, в случае их возникновения калькулятор просто пропускает соответствующую команду. На уровне `Calculator` могут возникнуть ошибки, критичные для работы программы, например, отстутствие конфигурационного файла. В случае такой ошибки работа программы прекращается.

## Модульное тестирование
Для каждой команды существует класс формата `%commandName%Test`, содержащий тесты конкретной команды. Тесты проверяют, что команда работает корректно, выкидывает нужные исключения в случае ошибок и при этом не изменяет состояние стека. Тестирование происходит с помощью библиотеки JUnit.

## Журналирование
Основной метод класса `Calculator` реализует журналирование посредством стандартных инструментов Java. В журнал записываются следующие события:
1. Успешная настройка `FileHandler` для журналирования.
2. Успешная загрузка конфигурационного файла, а так же сообщение о фатальной ошибки в случае неудачи.
3. Выбор режима программы: из файла или консоли в случае отсутствия или неправильного пути к файлу
4. Успешный парсинг команды.
5. Пропуск строки-комментария.
6. Успешное выполнение команы, и, в случае неудачи, причина ошибки и предупреждение о пропуске неправильной команды.
